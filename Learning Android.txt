надо прописать план как я вижу то за что получу бабла


Андроид. Учимся.


Тем временем вопросы и заметки по Kotlin.
По умолчанию все классы в Котлине - финализированные. Наследоваться нельзя. Чтобы можно было наследоваться от класса, надо написать open перед объявлением класса. В основном приложении так сделано с классом StatelessUITest.

Что нового узнал пока читал документацию по Kotlin:
- когда в стринге мы используем шаблоны, то мы не просто можем использовать там переменные, а еще и совершать над ними операции.
Пример: val s2 = "${s1.replace("is", "was")}, but now is $a"

- Реализация метода может быть сделана без фигурных скобок. чисто через равно. Так же, оператор if может быть использован как выражение. Пример: 
fun maxOf(a: Int, b: Int) = if (a > b) a else b

- when это крайне функциональная версия switch-case.
Боюсь представить сколько всего можно навертеть с его помощью.

fun describe(obj: Any): String =
    when (obj) {
        1          -> "One"
        "Hello"    -> "Greeting"
        is Long    -> "Long"
        !is String -> "Not a string"
        else       -> "Unknown"
    }

- Оператор in. Я много раз видел его, но не задавался вопросом как оно устроено. Настолько интуитивно понятно, что даже не возникало вопросов.

if (x in 1..y+1) {
    println("fits in range")
}

- может оказаться очень полезной проверка на то, находится ли проверяемая величина в заданных пределах. Не знал.
if (-1 !in 0..list.lastIndex) {
    println("-1 is out of range")
}

- Так же in используется в for и получается конструкция куда более читаемая, чем в жабе.
for(x in 1..10) ...






https://developer.android.com/courses/android-basics-kotlin/android-basics-kotlin-vocab - словарик терминов в андроиде.

Views
TextView
ViewGroups


!!!!! 2. Урок "Set up your happy birthday app" !!!!!

Все элементы что мы видим на экране это View. Не совсем понятно , что это, класс View или такое просто обозначение?
пока что примерно понимаю так: вью это класс-родитель. От него наследуются остальные. но не видел этого точно.
Вопрос. Как найти класс View в проекте? особенно если это пустой проект. так то это ж базовые предоставляемый андроидом класс. сходу найти не могу, хотя вообще в проекте Документов находил.
Вопрос. Не могу получить доступ к гитлабу и всему такому, хотя впн подключен и джира работает, хотя без впн не работало бы.
Наблюдение: вьюхи не висят просто сами по себе. Они имеют взаимосвязь с другими Вьюхами. ViewGroups отвечают за группировку вьюх. Один из представлений(?) ViewGroups является ConstraintLayout. Позволяет как то располагать вьюхи на экране.
Наблюдение. Есть известный нам и примерно понятный Layout Inspector, а есть Layout Editor. Это как раз для редактирования экранов. Пока не разобрался.
	Помимо окна Project, которое слева и нам давно знакомо, есть еще 2 больших окна в центре. 
	Слева это вид Дизайна (design View, уточнить как называется по-русски). Тут видно как окно будет выглядеть когда запустится.
	Справа это Чертеж или План (Blueprint). Тут будем создавать экран. Тут все проектируется, судя по всему.
	А еще левее есть окошко "Палитра" (Palette) - тут перечислены те вьюхи, которые мы можем вставлять в наш экран.
	Ниже палитры расположена зона Дерева Компонентов. Тут, судя по всему, описано дерево компонентов. Иерархия того, что у нас в приложухе уже есть.
	А вообще совсем справа расположено окно Атрибутов. Тут свойства вьюх. Что то подобное есть в Layout Inspector.
	
В окне Project есть такие папки:
App - тут почти все файлы, которые связаны с приложением
res - папка с ресурсами. Картинки, верстка экранов, может быть текста и все такое. Все наполнение приложения.
	В res есть папка Layout - тут всякие верстки. Что это такое - пока что не понятно.

Вопрос. ConstraintLayout - что это такое? зачем оно надо? Пока что видно что это что то типа хранилища для других объектов или типа того.
Вопрос. "The TextView is indented because it is inside the ConstraintLayout." - что это значит?
Вопрос. И все таки. Какого черта бывает так что в дереве компонентов у элемента есть текст, а в Laout Inspector этого текста нету?

!!!!! 3. Урок "Add TextViews to the layout". !!!!!


По уроку мы снесли имеющийся TextView, а после этого добавили новый. Но когда добавили, появился ворнинг типа " у нового элемента не заданы constraints. Типа нужна какие то ограничения, иначе когда будет запущено приложение, расположение нашего нового элемента изменится. Почему? Да хер его знает.
Короче надо внедрить ограничения по расположению с 2 сторон. Варианты: Сверху слева, сверху справа, снизу слева, снизу справа. Есть еще вариант давать зависимости о расположению относительно элемента. Пока не в курсе.
Добавляем шрифт, размер теста, цвет.
Идем в Атрибуты, там вкладка Common atributes. В ней textAppearance. Разворачиваем. 
textSize. Указываем как 36sp. sp - обязательно. Это как единица измерения, без нее будет ругаться и говорить что без sp это неизвестный юнит.
Важно. Есть dp и sp.
dp - density-independent pixels which you used earlier for the layout, 
sp- scalable pixels
По идее это одно и тоже, но есть какая-то разница.
Вопрос. Какая ризница между sp и dp?
fontFamily это типа вид шрифта. Курсив, обычный, почерк и все такое. casual это как почерк. Ну почти.
Вопрос. Что подразумевается под Solution Code ? Там что то связанное с тем когда твой код был загружен на гитхаб. уточнить бы.
А еще можно вставить какой то объект (щас речь о картинке) и отцентровать его. Для этого надо в окне констрейтов выставить все 4 ограничения со значением 0.
А что бы растянуть картинку на весь экран надо: в атрибутах ищем scaleType и его выставляем как centerCrop. И все. Растянется красиво. Там вообще много вариантов что можно делать с текстуринами.
Но теперь у нас пропал текст. Чтоб он появился, надо изображение поставить ЗА текст. Как сделать: в дереве компонентов растащи элементы от менее приоритетных по видимости к более приоритетным. Чем выше элемент, тем ниже его приоритет.
Далее. Вставлять текст в виде хардкодной стринги это херовая практика. Хорошей практикой будет подтягивать стрингу как ресурс. Так и надежней, и лучше для единения одинаковых стрингов в разных местах, а еще упрощает перевод на разные локали.
Как это сделать: надо вызвать диалог Extract Resource. Либо это можно сделать из подсказки на ворнинге о хардкодном тексте, либо провалиться в xml где расположена хардкодная стринга, по ней тап правой мышью, и там будет экстракт текст. Дальше диалоговое окно все подскажи и поможет.
Вопрос. В каком случае стринги раскидывают по разным файлам? Подозреваю что на разных экранах разных стрингофайлы.

!!!!! 4. Урок Создание кнопки в приложении. (переименуй потом как надо) !!!!!
Будем делать приложуху где мы по нажатию кнопки будем типа кидать игровой кубик с 6 гранями.
Для этого нас шлют в песочницу и говорят что мол напишем код где будет рандомайзер.
fun main() {
    val diceRange = 1..6
    val randomNumber = diceRange.random()
    println("random number: $randomNumber")
}

Потом нам показывают как создавать объекты. 

fun main() {
    val myFirstDice = Dice()
    println(myFirstDice.sides)
}

class Dice {
    var sides = 6
}

тесты для редактора пометь что их делать надо в основном проекте. для этого надо отсортировать все стори как раньше было оговорено. по тэгам, скорей всего.


Что бы импортировать медиа (например, картинки), надо открыть View -> Tool Windows -> Resource manager -> в открывшемся ресурс менеджере кликнуть на плюсик (прям под заголовком ресурс менеджера) и выбрать "импорт драваблес". Дальше просто через проводник выбираем нужную медию.

Текстовые ресурсы. Не хардкодь. Это прям плохо. Создав объект с текстом, обязательно найди его в xml'ине и сделай extract resources.

Активити. Типа это окно, в котором наше приложение отрисовывает пользовательский интерфейс. В приложении может быть одно активити или несколько. Вроде как я слышал что раньше было модно делать много активитей, а щас стараются придерживаться практики "одно активити на всю приложуху".

Для чего нужна активити? Знаю что для: 
- для отрисовки объектов (вьюх) на экране
- Для описания правил взаимодействия юзера с интерфейсом (очень абстрактно описано, конечно)
(кстати интересно как взаимосвязаны активити с композом)

Еще интересно было бы узнать о том что могут быть приложения с одной активити, а могут быть с несколькими. Кажется что современная практика (модная) это одна активити на всю приложуху. Но это не точно. МО вон на нескольких активити работает и ничего.

Логирование.

Log.e() - ошибки. Самый ахтунг.
Log.w() - ворнинги. 
Log.i() - информационные сообщения
Log.d() - отладочное
Log.v() - Тут содержатся все вышеописанные.

Все они однотипны по параметрам. У них их 2: тэг и сообщение. Тэг - опознавательный знак. Может быть, имя класса. Сообщение - что ты хотел сказать. Ну, например, сообщить что если эта строка залогировалась, то этот блок кода все таки был вызван. А еще можно туда запихать строковое представление значения какой-нибудь важной переменной.

Какая капитальная разница между crash и Exception? 
и что такое fatal ecxeption? 
А еще википедии пишут что есть Fatal Error и System fatal error. Што.

Спросить разработчиков как они читают стектрейс. Я то читаю сухую короткую выжимку, которая говорит мне какая цепочка методов в тестах посыпалась, а там же десятки строк. Очень много. Это надо хоть немного?

Поговорил с Артемом. Короче проходить этот курс до конца - дурка. Лучше тогда взять да написать для начала калькулятор(поработать с кнопками, внутренней логикой обработки событий, внешним видом кнопок). Потом сделать конвертер(дернуть апишку). Можно еще что то со звуком поделать.

Построение кнопок в рамках constraint'ов через chain. Между всеми кнопками должны быть взаимные зависимости по расположению на экране.
Нам тут подсказывают что строить UI следует не через UI'ные инструменты студии, а через xml'ки. Нормальная тема.

как внятно логировать?  Log.d("myTag", "This is my message"); вот это надо будет проверить. Таким образом можно распечатать метку типа когда хочется проверить что вот такой то блок кода в реальности был выполнен. А если я хочу печатать в логи что-то из кода? значение какое то или типа того?

Был долгий перерыв. Пока вкатывался (и не вкатился) почитал про язык.

Про nullable.
Если ты создаешь метод и возвращаемое значение почему то может окзааться null, пиши возвращаемый тип как Int?

типы данных бывают обнуляемые(nullable) и необнуляемые(non-nullable). Обнуляемые помечаются "?". Если ? не поставить, тотип будет не обнуляемым (всегда?).

когда ты делаешь действие над переменной наллбл(через dot call), то надо указывать ? в конце имени переменной, иначе зкомпилятор аругается - наллбл переменные надо вызывать безопасно, с указанием того что они наллбл (как описал выше - через вопросик в конце). Зачем? Так Котлин предупреждает что вызываемая переменная может вернуть null. Если у переменной значение не null, то будет совершено запрограммироанное действие. Если же в переменной хранится null, то действие будет пропущено (?што?) вот я бы задал вопрос умным товарищам - как это так? разве реально ничего не происходит? Когда выводишь на печать результат действия места, которое должно быть (как утверждается) пропущено, то печатается null. А точно пропускается действие? Как это связано с тем что печатается null? Спроси у опытных.

Элвис.
val a: Int = someVal.length ?: 1
тут вот что: Переменной а будет присвоено someVal.length. А если это значение будет null, то вместо него будет присвоено 1.


The is operator checks if an expression is an instance of a type. If an immutable local variable or property is checked for a specific type, there's no need to cast it explicitly:

я правильно понимаю что если я использую is, то если проверка на соответствие типа проходит успешно, то сразу автоматически происходит приведения к проверяемому типу?

member functions это что такое? Типа функция описанная в классе и вызываемая у объекта?

Overriding methods always use the base method's default parameter values. When overriding a method that has default parameter values, the default parameter values must be omitted from the signature:

open class A {
    open fun foo(i: Int = 10) { /*...*/ }
}

class B : A() {
    override fun foo(i: Int) { /*...*/ }  // No default value is allowed.
}

чот слабо понял. при наследовании используются значения параметров по умолчанию от родителя, но следующим предложением же пишут что нет, нафиг, запрещено использовать значения по умолчанию от родителя. што.


Еще раз. Не понял. Есть какое то ключевое слово что бы можно было один из параметров метода сделать необязательным. Типа он по умолчанию какойта и его можно не указывать. Кажется даже ключевого слова для этого не надо.

Еще очень интересный вопрос: как разбираться в коде если ты что то там писал, писал херово, ничего не понятно, а понять охота? Вот мне щас считай заново вкатываться в проект свой. И я хз с чего начать.

inputTextToActiveTextField - я снова не понял как эта ебала работает. Не понимаю как ее читать. Там то ли про функциональные интерфейсы, то ли хз что это такое.
Помню что мне с этим помогал Володя и помню что он сказал что там как бы видно что ожидается что надо вводить лямбду. Вот понять бы как он это понял...

Кажется, я не описал используемые в проекте UI-элементы.

Button - просто кнопка.






https://habr.com/ru/companies/touchinstinct/articles/326814/ - добротная статеечка о констрейнтах.
Свойства UI-элементов в xml-файле:
- id - понятно. берется из пула айдишников. Повторить бы где этот пул. быстро не нашел.
- layout_width - ширина элемента. Много где у меня стоит ="wrap_content". Это значит "по ширине" (АРТЕМ!!!)
- layout_height - высота. то же что по ширине.
- text - какой текст содержит элемент. Текст, крайне желательно, должен быть не захардкоженным, а быть в стрингах. Как и айдишники. R.id / R.string и вот это все.
- textSize - размер текста. Измеряется в 2 величинах: sp/dp
dp (density-independent pixels) — независимые от плотности пиксели. Абстрактная единица измерения, основанная на физической плотности экрана с разрешением 160 dpi. В этом случае 1dp = 1px;
sp (scale-independent pixels) — независимые от масштабирования пиксели. Допускают настройку размеров, производимую пользователем. Полезны при работе с шрифтами;
чо каво выбирать - я пока не знаю.
- layout_constraintBottom_toTopOf - 


марджин - отступ

layout_constraint... - много подобных методов (?). Определяет зависимости. Типа где начало одного элемента находится относительно начала другого. Или еще как. Много вариантов.

layout_constraintHorizontal_bias - вот этот параметр не понятен. Он у меня постоянно имеет значение "0.5". Что это?

[QUESTION]: как все таки создавать цепи (chains) что бы не через UI?


autofill hints - надо понять как это заполнять.

В ConstraintLayout есть понятие Baseline - линия по которой выравнивается контент.


Пошел по статейке про констрейнты. Армен младший говорит что годная.

Есть Constraing Layout. Это штука в которую запихиваются UI-элементы.
Нужна чтоб делать масштабируемые интерфейсы. Если правильно понял, суть в том что размеров дисплеев телефонов много, а проект один. И constraint layout нужен чтоб спроетировать как расположение элементов, так и заложить масштабируемость элементов для разных экранов.
В рамках Constrait Layout существует constraints. Это линии. Их 4. Это как бы ограничители, от которых можно отталкиваться при размещении элементов. Как в Автокаде привязки делать можно. Зависимости.
Констраинты бывают:
Горизонтальные (правой стороны, левой стороны, начальной стороны (start), конечной стороны (end))
Вертикальные (верхней стороны, нижней стороны, базовой линии (baseline))
Чот слабо понятно. Читаем дальше.
Вертикальные и горизонтальные констраинты друг с другом не связаны. Допустим. А что, одной ориентации констраинты связаны?
[Question]: А констраинты для одного экрана делаются или для всех размеров экранов свои?
Baseline - линия выравнивания контента элемента. Типа для каждого элемента своя?
Для текст вьюхи это линия, на которой располагается низ текста. Если у вьюхи выставлен бейзлайн констраинт, то базовая линия элемента (а это еще что такое?) будет находиться на уровне базовой линии вьюхи, к которой привязан констраинт. [Question]: А базовая линия элемента и базовая линия вьюхи это не одно и то же? Вьюха это не есть элемент?..

Если я правильно понял, у каждой вьюхи есть констраинты. Я думал что констраинт это линии ограничивающие весь экран. Кажется, что это не так. upd: а есть и так, и сяк.

Короче, есть левый констреаинт, есть правый (щас как пример) и если у тебя есть 2 элемента, то ты можешь привязать лево элемента 2 к право элемента 1 и получится что вот у тебя есть элемент 1, а справа от него прикреплен элемент 2.

Пока что остановился на match_parent. Не особо понял что это такое.

Отступы бывают внутренние и внешние. 
Внутренние отступы имеют атрибут android.padding. Типа есть текст или какой то центровой элемент (текст в кнопке, поле ввода текста в текстовом поле или типа того). И паддинги позволяют задать отступы от границ вьюхи до центрового элемента.
Внешние отступы (matgin) это про расстояние от края вьюхи до границ констраинта (вроде кроме констраинта больше некуда привязываться).


layout_marginLeft - отступ от левой границы (только не очень понятно - от левой границы экрана вообще или от линии констраинта?)
layout_margin - единый отступ ото всех краев. (интересно как это - от одного края, от второго... а до 3 и 4 же автоматически вычисляется. или просто обозначаются границы до следующих элементов?..) - попробовал, не очень вышло - ничего не меняется. странная история. у разрабов уточнить.

margin_horizontal - отступ и слева, и справа.
margin_vertical - соответственно, и сверху, и снизу.
вот эти два отступа это что то типа "от меня все отошли на хх dp/sp, с такой-то стороны, ближе не приближаться!". Что-то такое.

Поигрался с пустым проектом, потаскал кнопочки туда-суда. Что понял?
Есть маржины. Есть цепи. Есть констраинты. Вот это как бы основной инструментарий.

А еще мне студия подсказывает что есть autohints. Пока что кладу на это болт.

вот сообщение от Армена младшего:
"Самое основное что нужно узнать - чейны, барьеры, группы, что такое 0dp, как задавать констрейнты в коде, поиграться с видимостью вьюх имеющих констрейнты, в целом паддинги, маржины , анимация через constraintset"

Я что то из этого понял, но задрачивать не имею никакого желания. По крайней мере сейчас. Пойду итеративно. Что-то понял, пошел дальше, вернулся, посмотрел на свое творение, сделал рукалицо, допилил, стало лучше, пошел дальше.


Решил тут повторить жизненный цикл приложения.
офф дока: https://developer.android.com/guide/components/activities/activity-lifecycle

[QUESTION]: какая разница между коллбэком и листенером? Я понимаю что вещи разные, но пока что у меня в голове мысль типа "коллбэк начинает работать когда совершено определенное дейстаие. Листенер сообщает когда совершено определенное действие.". Чо? Каво?..

[QUESTION]: А жизненный цикл активности и жизненный цикл приложения это одно и тоже? Задал этот вопрос Армену младшему. Ответ: если приложение спроектировано на одной активности, то да, одно и то же. Если нет, то там что то как то по другому. Как - не знаю. А надо оно щас?..

По жизненному циклу имеем вот что. В официальном гайде по жизненному циклу активности нашел картинку. Отпишу ее тут текстом.
Статья, кстати, вот:
https://developer.android.com/guide/components/activities/activity-lifecycle#oncreate

                                                                                                             
                Activity launched                                                                         
                         |
                         V                                                                              
     -------------> onCreate()                                                                             
     |                   |
     |                   V
 Юзер переходит     onStart()       <----------------------------------------       
 к активности            |                                                  |
     |                   V                                                  |
     |              onResume()      <---------------------                  |
     |                   |                               |                  |
 Процесс нашего          V                               |Юзер              |
 приложения умер    Activity running                     |возвращается к    |
     |                   |                               |активности        |
     |                   V                               |                  |Юзер
     |              Другое приложение вылезло            |                  |переходит
     ^              на передний план                     |                  |к активности
     |                   |                               |                  |
     |                   V                               |                  |
     ------------<  onPause()         --------------------                  |
     |                   |                                                  |
  Приложению с           V                                                  |
  бОльшим           Наша активность                                         |
  приоритетом       больше не видна                                         |
  нужна память           |                                                  |
     |                   V                                                  |
     ------------<   onStop()         ---------------------------------------
                         |
                         V                                                                                    
                    Активность убита пользователем                                                      
                    или уничтожена системой                                                         
                         |
                         V                                                                                   
                    onDestroy()                                                                 
                         |
                         V                                                          
                    Прекращение деятельности 
                    активности (shut down)


[QUESTION]: А вот есть методы onCreate(), onStart(), onResume(). Правильно понимаю что при запуске активности они все трое сразу запускаются последовательно?
[QUESTION]: А почему в цикле нет сценария когда вот у меня приложение было на переднем плане, а я взял и убил его? Это ж очень жизнеспособно. Или я чего то не понимаю?
[QUESTION]: А вот сценарий когда возникла необходимость отдать память приложению с большим приоритетом. Есть шаг "процесс нашего приложения умер". А как это происходит? Автоматически сам Андроид распедаливается или что то писать для этого надо?

https://stackru.com/images/ac4ebc00019f0d31d61bfc2b6c00804433a6e1a4.png
вот тут еще очень интересная пикча. ЗАДАЙ ВОПРОС РАЗРАБАМ НАДО ЛИ ЭТО УЧИТЬ!